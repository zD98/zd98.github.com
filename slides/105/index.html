<!DOCTYPE html>
<html>
<head>
<title>JS函数总结</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>JS函数总结</h1>
<h2>函数</h2>
<ol>
<li>
<p>函数创建</p>
<p>函数声明：</p>
<pre><code>function Foo(){}    
Foo.name == &quot;Foo&quot;  //true
Foo = null;
</code></pre>

<p>函数表达式：</p>
<pre><code>var Foo = function(){}； 
Foo.name == &quot;&quot;  //true
</code></pre>

<p>以上Foo都是指向函数的指针</p>
<p>解析器率先读取函数声明, 并使其在执行任何代码之前都可用(变量提升)</p>
<p>函数表达式必须等到解析器执行到函数所在代码行才被解析执行</p>
</li>
<li>
<p>函数 == 变量</p>
<p>JS中, 函数可以作为变量值进行传递(传的值都是引用)</p>
</li>
<li>
<p>函数内部属性</p>
<p>函数内部有两个特殊对象</p>
<ul>
<li>
<p>arguments</p>
<pre><code>0. 函数参数
    没有传递值的参数自动被赋值undefined 
1. 类数组对象, 实际长度是传递参数的数量(不是定义参数的数量),可通过[]访问其元素
2. 函数参数与arguments中的值是一一映射的, 即改变了arguments的值, 函数参数也会改变
3. callee与caller
    callee:指向拥有这个arguments的函数
    caller:保存当前调用函数的函数的引用
        function outer(){
            inner();  //function  outer
        }
        function inner(){
            console.log(arguments.callee.caller);
        }
        outer(); //function outer
        inner(); //null  全局作用域 值为null
</code></pre>

</li>
<li>
<p>this </p>
<ol>
<li>
在不适用call, apply, bind的情况下,  当是对象调用的函数, this指向调用的对象
,不是对象调用的函数, this指向全局
</li>
<li>
call, apply, bind
可以改变this的指向--具体看下一节
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>函数属性和方法</p>
<ul>
<li>length: 函数希望接受的参数个数</li>
<li>prototype:对于所有引用类型, prototype保存了它们所有实例方法</li>
<li>
<p>apply 与 call</p>
<ul>
<li>在特定作用域下调用函数, 即设置函数体内this的值</li>
<li>
apply()
<ol>
<li>接受两个参数, 第一个是运行函数的作用域，第二个是参数数组</li>
<li>参数数组可以是[], 也可以是arguments</li>
</ol>
</li>
<li>
call()
<ol>
<li>第一个参数是运行函数的作用域</li>
<li>其余参数做为函数的参数传递给函数	</li>
</ol>
</li>
<li>
<p>bind()		</p>
<ol>
<li>bind是对call,apply的补充, 因为call和apply会直接运行函数</li>
<li>bind绑定了运行函数的作用域, 但是不运行</li>
<li>
<p>bind的polyfill</p>
<pre><code>if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
    var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this, //this在这里指向的是目标函数
        fBound = function () {
            return fToBind.apply(
                //如果外部执行var obj = new fBound(),则将obj作为最终的this，放弃使用oThis
                this instanceof fToBind
                        ? this  //此时的this就是new出的obj
                        : oThis || this, //如果传递的oThis无效，就将fBound的调用者作为this

                //将通过bind传递的参数和调用时传递的参数进行合并，并作为最终的参数传递
                aArgs.concat(Array.prototype.slice.call(arguments)));
        };

        //将目标函数的原型对象拷贝到新函数中，因为目标函数有可能被当作构造函数使用
        fBound.prototype = this.prototype;

        //返回fBond的引用，由外部按需调用
        return fBound;
    };
}   
</code></pre>

</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2>作用域</h2>
<ol>
<li>
<p>执行环境及作用域</p>
<pre><code>1. 执行环境：(context), 每个函数有自己的执行环境
    当执行流进入一个函数时，函数的环境会被推入一个环境栈, 函数执行之后, 栈将其环境弹出, 并将控制权交还给之前的执行环境
2. 变量对象：
    每个执行环境都有与之关联的变量对象, 环境中定义的所有变量和函数都保存在这个对象中
3. 作用域链：
    当代码在一个环境中执行时, 会创建变量对象的一个作用域链, 作用域链保证对执行环境的有序访问。
4. 活动对象：
    包含arguments, 在函数运行时做变量对象使用
</code></pre>

</li>
<li>
<p>流程</p>
<pre><code>1. 在一个执行环境A中（全局或者某个函数）/ 全局环境
2. 执行环境的作用域链 是[[scope]]的副本 /  全局环境没有作用域链？(自己的推测) 
3. 在作用域链中推入当前活动对象(由arguments和其他变量值初始化) / 全局环境活动对象==全局对象
4. 在此执行环境A中,创建了一个函数F
5. 函数F的[[scope]]保存了当前执行环境A的作用域链（指针列表） / 若是全局环境，则创建一个包含全局对象的作用域链
6. 运行函数F时, 创建了执行环境B...-&gt; 跳转至 1
7. 执行环境A 运行结束, 其活动对象(变量对象)和作用域链(都是指针)会被销毁 /全局环境在关掉浏览器或页面时销毁
</code></pre>

</li>
<li>
<p>作用域链</p>
<pre><code>因为内部作用域(执行环境)的作用域链中保存中父级,祖父级,祖宗级(直到全局对象)的引用,
所以内部作用域可以调用外部作用域的变量
查询过程：从作用域链起,(即第一个对象是当前活动对象),遍历作用域链, 查找变量
</code></pre>

</li>
</ol>
<h2>闭包</h2>
<ol>
<li>
介绍及原理
<ol>
<li>闭包:有权访问另一个函数作用域中变量的函数</li>
<li>依靠于函数的作用域链,闭包函数的作用域链保存了父级作用域的活动对象的指针 </li>
<li>看懂上面作用域闭包就挺好理解了...吧？</li>
</ol>
</li>
<li>
<p>使用</p>
<ul>
<li>模拟块级作用域</li>
<li>在对象中创建私有变量</li>
<li>抽象， 模拟类</li>
<li>匿名自执行函数</li>
<li>缓存-让变量的值保存在内存中</li>
<li>
<p>测试题</p>
<pre><code>function fun(n,o) {
  console.log(o)
  return {
    fun:function(m){
      return fun(m,n);
    }
  };
}
var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,0,0,0
var b = fun(0).fun(1).fun(2).fun(3);//undefined,0,1,2
var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,0,1,1
</code></pre>

</li>
</ul>
</li>
<li>
<p>影响</p>
<ul>
<li>
<p>闭包与变量</p>
<pre><code>var arr = function(){
    var arr = [];
    for(var i =0;i&lt;4;i++){
        arr[i] = function(){
            console.log(i);
        }
    }
    return arr;
}();
arr[2](); // 4
</code></pre>

</li>
<li>
<p>闭包与this</p>
<pre><code>var obj = {
    name:&quot;test&quot;
    func:function(){
        return function(){
            console.log(this.name);  //wrong  this -&gt;window
        }
    }       
}
</code></pre>

</li>
<li>
<p>内存泄漏</p>
<pre><code>var ele = function(){
    var ele = {};
    ele.func = function(){
        console.log(ele.name);  //保存了对ele的引用+1
    }
    return ele;
})();

因为ele.func 产生了循环引用, 即保存了对父级作用域的引用,ele的引用至少为1,
所以不能被自动回收

ele = null; // 不会使内存自动回收
ele.func = null;
ele = null; // 内存才会释放
</code></pre>

</li>
</ul>
</li>
</ol>
<h2>原型</h2>
<ol>
<li>
构造函数
<ul>
<li>
使用构造函数创建对象 new Func
<ol>
<li>创建一个对象</li>
<li>将构造函数的作用域赋给新对象</li>
<li>执行构造函数中的代码</li>
<li>返回这个对象</li>
</ol>
</li>
</ul>
</li>
<li>
原型对象
<ul>
<li>每个函数都有prototype属性, 它是一个指针, 指向了一个对象</li>
<li>这个原型对象用于包含特定类型所有实例共享的属性和方法</li>
<li>原型对象会自动获得constructor属性, 指向prototype属性所在函数的指针</li>
<li>通过构造函数的实例创建的对象中保存了[[Prototype]]指向构造函数的原型对象</li>
</ul>
</li>
<li>
<p>原型链</p>
<ul>
<li>一个原型对象等于另一个类型的实例</li>
<li>这个实例中保存了一个指向它的类型的原型对象</li>
<li>如上形成了原型链</li>
</ul>
</li>
<li>
<p>原型链使用</p>
<pre><code>1  function A(){}
2  function B(){}
3  
4  B.prototype = new A();
5  
6  A.prototype.sayName = function(){console.log(&quot;A&quot;);}
7  
8  var b = new B();
9  b.sayName(); // &quot;A&quot;
10 
11 A.prptotype = {
12   constructor:A,
13   sayName:function(){console.log(&quot;AAAA&quot;);}
14 }
15 
16 b.sayName(); // &quot;A&quot;
</code></pre>

<p>上述代码 两次输出都是A, 而据我们所知, 原型被改变了后, 它会影响所有继承原型的实例与类
但是这里没有！来分析一下。</p>
<p>第1,2行:定义了构造函数A,B, 他们的原型对象都是Object</p>
<p>第4行:  修改B的原型对象, 将A的一个实例(假设是a)赋给了B的原型</p>
<pre><code>    B.prototype = a; a.constructor = A; a[[Prototype]] = A.prototype;
</code></pre>

<p>第6行:  修改了A.prototype, 添加了sayName() </p>
<pre><code>    A.prototype = Obj;//Obj是默认对象
    Obj.sayName = function(){};
</code></pre>

<p>第8行:  创建了B的一个实例b
		b[[Prototype]] = a;  a[[Prototype]] = A.prototype;A.prototype-&gt;Obj;</p>
<p>第9行:  b调用sayName(), b没有这个函数,通过原型链调用了a的sayName;</p>
<p>第11行: 修改了A.prototype = Obj2;</p>
<pre><code>    Obj2 = {
        constructor:A,
        sayName:....
    }
    A.prototype 指向了Obj2
</code></pre>

<p>第16行: b.sayName() 输出A</p>
<pre><code>    此时b的原型链
    b[[prototype]] == a; a[[prototype]] == Obj;
    Obj.constructor == A; 
    A.prototype == Obj2;
    Obj.sayName == function(){console.log(&quot;A&quot;);}

    根据上述, 实例b的原型a的原型是Obj;
    更改了A.prototype的引用, 就切断了A.prototype与Obj的联系
    所以说[[prototype]]中保存的不是构造函数的prototype指针, 
    保存的是与prototype指向相同的那个对象
</code></pre>

</li>
<li>
<p>测试</p>
<pre><code>function Foo() {
    //全局getName
    getName = function () {
        console.log(1);
    };
    return this;
}
//Foo的属性
Foo.getName = function () {
    console.log(2);
};
//原型
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
//函数提升
function getName() {
    console.log(5);
}
//请写出以下输出结果：
Foo.getName(); //2
getName();     //4
Foo().getName();//1
getName();      //1
new Foo.getName();//2
new Foo().getName();//3
new new Foo().getName();//3
</code></pre>

</li>
</ol>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
